Решение задач
=============

Мы рассмотрели различные части языка Python, и теперь посмотрим, как все эти
части работают вместе, проектируя и составляя программу, которая *делает* что-то
полезное. Цель состоит в том, чтобы научиться писать сценарии на языке Python
самостоятельно.

Задача
------

Перед нами стоит следующая задача: *Составить программу, которая создаёт 
резервные копии всех наших важных файлов*.

Хотя задача и проста, информации явно недостаточно, чтобы приступать к её 
решению. Необходим некоторый дополнительный **анализ**. Например, как мы 
выберем, *какие* файлы необходимо копировать? *Как* их хранить? *Где* их 
хранить?

После надлежащего анализа мы **проектируем** нашу программу. Мы создаём список,
описывающий то, как наша программа должна работать. В данном случае я создал
список того, как *я* себе представляю её работу. Когда вы проектируете 
программу, у вас может получиться другой результат, поскольку каждый человек
представляет себе это по-своему, так что это в порядке вещей.

1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
2. Резервные копии должны храниться в основном каталоге резерва.
3. Файлы помещаются в zip-архив.
4. Именем для zip-архива служит текущая дата и время.
5. Будем использовать стандартную команду ``zip``, имеющуюся по умолчанию в 
   любом стандартном дистрибутиве GNU/Linux. Пользователи Windows могут 
   `установить <http://gnuwin32.sourceforge.net/downlinks/zip.php>`_ её со
   `страницы проекта GnuWin32 <http://gnuwin32.sourceforge.net/packages/zip.htm>`_
   и добавить "``C:\Program Files\GnuWin32\bin``" к системной переменной 
   окружения PATH, аналогично тому, как мы это 
   :ref:`делали <installation-dos-prompt>` для самой команды "python". Обратите 
   внимание, что для этого подойдёт любая команда архивации, если у неё есть 
   интерфейс командной строки, чтобы ей можно было передавать аргументы из 
   нашего сценария.


Решение
-------

Как только проект программы более-менее устоялся, можно приступать к написанию 
кода, который и будет являться **реализацией** нашего решения.

Сохраните как ``backup_ver1.py``:

.. sourcecode:: python

    import os
    import time

    # 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
    source = ['"C:\\My Documents"', 'C:\\Code']
    # Заметьте, что для имён, содержащих пробелы, необходимо использовать 
    # двойные кавычки внутри строки.

    # 2. Резервные копии должны храниться в основном каталоге резерва.
    target_dir = 'E:\\Backup' # Подставьте тот путь, который вы будете использовать.

    # 3. Файлы помещаются в zip-архив.
    # 4. Именем для zip-архива служит текущая дата и время.
    target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'

    # 5. Используем команду "zip" для помещения файлов в zip-архив
    zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

    # Запускаем создание резервной копии
    if os.system(zip_command) == 0:
        print('Резервная копия успешно создана в', target)
    else:
        print('Создание резервной копии НЕ УДАЛОСЬ')

**Вывод:**

::

    $ python3 backup_ver1.py
    Резервная копия успешно создана в E:\\Backup\\20080702185040.zip

Теперь наступает стадия **тестирования**, когда мы проверяем, правильно ли 
работает наша программа. Если она работает не так, как ожидалось, нам придётся 
заняться её **отладкой** (дебагом)\ [1]_, т.е. устранением **багов** (ошибок) в 
программе.

Если приведённая выше программа у вас не заработает, допишите 
``print(zip_command)`` прямо перед вызовом ``os.system`` и запустите программу. 
После этого скопируйте выведенную команду "zip_command" и вставьте её в 
командную строку, чтобы проверить, работает ли она корректно сама по себе. Если
она не срабатывает, проверьте справку по команде "zip", чтобы выяснить, в чём
может быть проблема. Если команда успешно выполняется, проверьте, совпадает ли
ваша программа на Python в точности с программой, приведённой выше.

**Как это работает:**

    Вы заметили, как мы превратили наш *проект* в *код* шаг за шагом.

    Мы использовали модули ``os`` и ``time``, предварительно  импортировав их. 
    Далее мы указали файлы и каталоги для резервного копирования в списке 
    ``source``\ [2]_. Каталог назначения -- это каталог, в котором мы сохраняем
    все резервные копии, и он указывается в переменной ``target_dir``. Именем
    zip-архива, который мы создаём, будет текущая дата и время, которые 
    генерируются при помощи функции ``time.strftime()``. У него будет расширение
    ``.zip``, и храниться он будет в каталоге ``target_dir``.

    Обратите внимание на употребление переменной ``os.sep`` -- она содержит
    разделитель пути для конкретной операционной системы, т.е. он будет ``'/'`` 
    в GNU/Linux и Unix\ [3]_, ``'\\'`` в Windows и ``':'`` в Mac OS. 
    Использование ``os.sep`` вместо этих символов напрямую делает программу 
    переносимой, и она сможет работать на всех этих операционных системах.

    Функция ``time.strftime()`` принимает в качестве аргумента формат вывода
    времени, например, такой, как мы указали в программе выше. Символ формата 
    ``%Y`` будет замещён годом и столетием. Символ ``%m`` будет замещён месяцем 
    в форме числа от ``01`` до ``12``, и так далее. Полный список таких символов
    формата можно найти в `справочнике по Python <http://docs.python.org/py3k/library/time.html#time.strftime>`_.

    Имя конечного zip-файла мы создаём при помощи оператора, который 
    *соединяет* строки, т.е. объединяет две строки и возвращает новую. После 
    этого мы создаём строку ``zip_command``, которая содержит команду, которую
    мы намерены выполнить. Проверить, работает ли эта команда, можно запустив
    её отдельно в командной оболочке (терминал в GNU/Linux или командная 
    строка DOS).

    Команда ``zip``, которую мы используем, имеет некоторые параметры. Параметр
    "``-q``" используется для указания, что команда должна сработать тихо\ [4]_.
    Параметр "``-r``" обозначает, что команда архивации должна работать 
    рекурсивно\ [5]_ для каталогов, т.е. должна включать все подкаталоги и 
    файлы. Оба параметра объединены и указаны в краткой форме "``-qr``". За 
    параметрами следует имя создаваемого zip-архива, за которым указывается 
    список файлов и каталогов для резервного копирования. Мы превращаем список 
    ``source`` в строку, используя уже знакомый нам метод ``join``.

    Затем мы, наконец, *выполняем* команду при помощи функции ``os.system``, 
    которая запускает команду так, как будто она была запущена из *системы*, 
    т.е. из командной оболочки. Она возвращает ``0``, если команда выполнена
    успешно, в противном случае она возвращает код ошибки.

    В зависимости от вывода команды, мы печатаем соответствующее сообщение о 
    том, успешным было создание резервных копий или нет.

    Вот и всё, мы создали сценарий для сохранения резервных копий наших важных
    файлов!

.. admonition:: Замечание для пользователей Windows

    Вместо управляющей последовательности для обратной наклонной черты могут
    использоваться "сырые"\ [6]_ строки. Например, можно писать 
    "``C:\\Documents``" или "``r'C:\Documents'``". Однако, **не** используйте 
    "``'C:\Documents'``", так как в этом случае окажется, что вы пытаетесь 
    применить неизвестную управляющую последовательность ``\D``.

Теперь, когда у нас есть рабочий сценарий резервного копирования, мы можем
использовать его для создания копий наших файлов. Пользователям GNU/Linux и 
Unix рекомендуется сделать этот программный файл :ref:`исполнимым <first-executable>`, 
чтобы иметь возможность запускать его в любое время из любого места. Это 
называется **операционной** фазой или **развёртыванием** программы.

Программа, приведённая выше, работает корректно, но (обычно) поначалу программы
не работают так, как вы того ожидаете. Проблемы могут возникать вследствие 
неправильного проектирования программы, допущения ошибки при наборе 
программного кода и т.д. В таких случаях приходится возвращаться к стадии 
проектирования или отладки программы.


Вторая версия
-------------

Первая версия нашего сценария работает. Тем не менее, его можно улучшить так,
чтобы было удобнее пользоваться в повседневной работе. Это называется стадией 
**поддержки** программы.

Одно из улучшений, показавшееся мне полезным, -- это лучший механизм именования
файлов: использование *времени* в качестве имени файла, сохраняющегося в каталог
с текущей датой в качестве имени, который в свою очередь, расположен в главном
каталоге для хранения резервных копий. Первое достоинство этого состоит в том,
что копии хранятся в иерархической структуре, которой легче управлять. Второе
достоинство -- в том, что имена файлов намного короче. Третье достоинство 
состоит в том, что по именам каталогов можно легко определить, в какие дни 
создавались резервные копии, так как каталог создаётся только в случае 
резервного копирования данных в этот день.

Сохраните как ``backup_ver2.py``:

.. sourcecode:: python

    import os
    import time

    # 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
    source = ['"C:\\My Documents"', 'C:\\Code']
    # Заметьте, что для имён, содержащих пробелы, необходимо использовать 
    # двойные кавычки внутри строки.

    # 2. Резервные копии должны храниться в основном каталоге резерва.
    target_dir = 'E:\\Backup' # Подставьте тот путь, который вы будете использовать.

    # 3. Файлы помещаются в zip-архив.
    # 4. Текущая дата служит именем подкаталога в основном каталоге
    today = target_dir + os.sep + time.strftime('%Y%m%d')
    # Текущее время служит именем zip-архива
    now = time.strftime('%H%M%S')

    # Создаём каталог, если его ещё нет
    if not os.path.exists(today):
        os.mkdir(today) # создание каталога
        print('Каталог успешно создан', today)

    # Имя zip-файла
    target = today + os.sep + now + '.zip'

    # 5. Используем команду "zip" для помещения файлов в zip-архив
    zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

    # Запускаем создание резервной копии
    if os.system(zip_command) == 0:
        print('Резервная копия успешно создана в', target)
    else:
        print('Создание резервной копии НЕ УДАЛОСЬ')

**Вывод:**

::

    $ python3 backup_ver2.py
    Каталог успешно создан E:\\Backup\\20080702
    Резервная копия успешно создана в E:\\Backup\\20080702\\202311.zip

    $ python3 backup_ver2.py
    Резервная копия успешно создана в E:\\Backup\\20080702\\202325.zip

**Как это работает:**

    Большая часть программы осталась прежней. Разница в том, что теперь мы 
    проверяем, существует ли каталог с именем, соответствующем текущей дате, 
    внутри главного каталога для хранения резервных копий. Для этого мы 
    используем функцию ``os.path.exists``. Если он не существует, мы создаём 
    его функцией ``os.mkdir``.

Третья версия
-------------

Вторая версия уже удобнее для работы с большим количеством резервных копий. С 
другой стороны, когда их много, становится трудно отличить, какая копия для 
чего. Например, мы могли внести значительные изменения в какую-то программу или 
презентацию, и теперь хотим указать суть этих изменений в имени zip-архива. 
Этого легко можно достичь добавлением пользовательского комментария к имени 
zip-архива.


.. note::

    Следующая программа не работает, так что не переживайте, просто проследуйте
    по ней, так как в ней содержится урок.

Сохраните как ``backup_ver3.py``

.. sourcecode:: python

    import os
    import time

    # 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
    source = ['"C:\\My Documents"', 'C:\\Code']
    # Заметьте, что для имён, содержащих пробелы, необходимо использовать 
    # двойные кавычки внутри строки.

    # 2. Резервные копии должны храниться в основном каталоге резерва.
    target_dir = 'E:\\Backup' # Подставьте тот путь, который вы будете использовать.

    # 3. Файлы помещаются в zip-архив.
    # 4. Текущая дата служит именем подкаталога в основном каталоге
    today = target_dir + os.sep + time.strftime('%Y%m%d')
    # Текущее время служит именем zip-архива
    now = time.strftime('%H%M%S')

    # Запрашиваем комментарий пользователя для имени файла
    comment = input('Введите комментарий --> ')
    if len(comment) == 0: # проверяем, введён ли комментарий
        target = today + os.sep + now + '.zip'
    else:
        target = today + os.sep + now + '_' +
            comment.replace(' ', '_') + '.zip'

    # Создаём каталог, если его ещё нет
    if not os.path.exists(today):
        os.mkdir(today) # создание каталога
        print('Каталог успешно создан', today)

    # 5. Используем команду "zip" для помещения файлов в zip-архив
    zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

    # Запускаем создание резервной копии
    if os.system(zip_command) == 0:
        print('Резервная копия успешно создана в', target)
    else:
        print('Создание резервной копии НЕ УДАЛОСЬ')

**Вывод:**

::

    $ python3 backup_ver3.py
    File "backup_ver3.py", line 25
    target = today + os.sep + now + '_' +
                                        ^
    SyntaxError: invalid syntax

**Как это (не) работает:**

    *Эта программа не работает!* Python сообщает об обнаружении ошибки 
    синтаксиса, что означает, что сценарий не удовлетворяет структуре, которую
    ожидает увидеть Python. Когда Python выдаёт сообщение об ошибке, он также
    указывает нам на место ошибки. Так что мы начинаем *отладку* программы с
    этой строки.

    При внимательном рассмотрении, мы видим, что одна логическая строка была
    разбита на две физические строки, но мы не указали, что эти две физические
    строки являются частью одной. На деле же Python просто обнаружил оператор 
    сложения (``+``) без соответствующего операнда в той же логической строке, 
    а поэтому не знает, как продолжать. Помните, что мы можем указать, что 
    логическая строка продолжается на следующей физической при помощи обратной 
    наклонной черты в конце физической строки. Внесём это исправление в нашу 
    программу. Коррекция программы при обнаружении ошибок и называется 
    **отладкой**\ [7]_.


Четвёртая версия
----------------

Сохраните как ``backup_ver4.py``

.. sourcecode:: python

    import os
    import time

    # 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
    source = ['"C:\\My Documents"', 'C:\\Code']
    # Заметьте, что для имён, содержащих пробелы, необходимо использовать 
    # двойные кавычки внутри строки.

    # 2. Резервные копии должны храниться в основном каталоге резерва.
    target_dir = 'E:\\Backup' # Подставьте тот путь, который вы будете использовать.

    # 3. Файлы помещаются в zip-архив.
    # 4. Текущая дата служит именем подкаталога в основном каталоге
    today = target_dir + os.sep + time.strftime('%Y%m%d')
    # Текущее время служит именем zip-архива
    now = time.strftime('%H%M%S')

    # Запрашиваем комментарий пользователя для имени файла
    comment = input('Введите комментарий --> ')
    if len(comment) == 0: # проверяем, введён ли комментарий
        target = today + os.sep + now + '.zip'
    else:
        target = today + os.sep + now + '_' + \
            comment.replace(' ', '_') + '.zip'

    # Создаём каталог, если его ещё нет
    if not os.path.exists(today):
        os.mkdir(today) # создание каталога
        print('Каталог успешно создан', today)

    # 5. Используем команду "zip" для помещения файлов в zip-архив
    zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

    # Запускаем создание резервной копии
    if os.system(zip_command) == 0:
        print('Резервная копия успешно создана в', target)
    else:
        print('Создание резервной копии НЕ УДАЛОСЬ')

**Вывод:**

::

    $ python3 backup_ver4.py
    Введите комментарий --> added new examples
    Резервная копия успешно создана в E:\Backup\20080702\202836_added_new_examples.zip

    $ python3 backup_ver4.py
    Введите комментарий -->
    Резервная копия успешно создана в E:\Backup\20080702\202839.zip

**Как это работает:**

    Теперь эта программа работает! Давайте просмотрим все улучшения, сделанные
    нами для версии 3. Мы запрашиваем пользовательский комментарий при помощи
    функции ``input``, а затем проверяем, ввёл ли пользователь что-либо, 
    определяя длину введённой строки функцией ``len``. Если пользователь просто
    нажал ``ENTER``, не вводя никакого текста (может быть, это было регулярное
    создание резервной копии, или никаких особых изменений внесено не было), мы
    продолжаем так же, как делали до сих пор.

    Если же комментарий был введён, он добавляется к имени zip-архива перед
    расширением ``.zip``. Обратите внимание, что мы заменяем пробелы в 
    комментарии подчёркиваниями: управлять файлами без пробелов в именах 
    намного легче.


Дополнительные усовершенствования
---------------------------------

Четвёртая версия -- вполне удовлетворительный рабочий сценарий для большинства
пользователей, однако нет пределов совершенства. Например, в программу можно
добавить уровень *подробности*\ [8]_ вывода, чтобы при указании параметра 
"``-v``" она становилась более "разговорчивой".

Ещё одним возможным улучшением была бы возможность передавать сценарию другие
файлы и каталоги прямо в командной строке. Эти имена можно получать из списка 
``sys.argv`` и добавлять к нашему списку ``source`` при помощи метода ``extend``
класса ``list``.

Наиболее важным усовершенствованием было бы прекращение использования 
``os.system`` для создания архивов, а применение вместо него встроенных
модулей ``zipfile`` или ``tarfile``. Они являются частью стандартной библиотеки,
поэтому всегда доступны для использования без зависимости от внешней программы 
zip на компьютере.

В приведённых примерах мы использовали способ с ``os.system`` для создания 
резервных копий исключительно в педагогических целях, чтобы пример был 
достаточно прост для понимания любым читателем, но достаточно реален для того, 
чтобы делать что-то полезное.

Попробуйте написать пятую версию с использованием модуля
`zipfile <http://docs.python.org/py3k/library/zipfile.html>`_ вместо вызова
``os.system``.


Процесс разработки программного обеспечения
-------------------------------------------

В процессе создания программы мы прошли через несколько **стадий**. Эти стадии 
можно свести примерно в такой список:

* Что (Анализ)
* Как (Проектирование)
* Создание (Реализация)
* Тестирование (Тестирование и Отладка)
* Использование (Развёртывание и Оперирование)
* Поддержка (Усовершенствование)

Процедура, которую мы прошли при написании сценария создания резервных копий 
рекомендуется и для других программ: Проведите анализ и проектирование. 
Начните реализацию с простейшей версии. Протестируйте и отладьте её. 
Попользуйтесь ею, чтобы убедиться, что она работает, как ожидалось. После
этого добавляйте любые необходимые функции, повторяя цикл 
"Создание-Тестирование-Использование" столько раз, сколько потребуется. Помните,
**Программы выращиваются, а не строятся**.


Резюме
------

Мы увидели, как создавать свои собственные программы/сценарии на Python, а также
различные стадии написания программ. На данном этапе вам будет полезно создать 
собственную программу по такому рецепту, как мы это делали в настоящей главе, 
чтобы лучше привыкнуть к Python, равно как и к решению задач.

Далее мы обсудим объектно-ориентированное программирование.


Примечания
----------

.. [1] debug -- применительно к компьютерным программам обозначает 
       `отладку <https://ru.wikipedia.org/wiki/Отладка_программы>`_ (обнаружение
       и устранение ошибок, которые при этом принято называть "bug", т.е. 
       "жук"). По всей видимости, это 
       `берёт своё начало <https://ru.wikipedia.org/wiki/Баг#Этимология>`_ с 
       процедуры изгнания насекомых из схем больших ЭВМ, хотя само понятие "bug"
       в смысле маленькой неисправности встречается и в более ранней литературе,
       например, в записях Томаса Эдисона 1878 года. (*прим. перев.*)
.. [2] source -- *англ.* "источник" (*прим.перев.*)
.. [3] Под словом "Unix" здесь подразумеваются все операционные системы, 
       построенные по принципам ОС Unix, а не только она сама по себе. 
       Примерами таких операционных систем являются все дистрибутивы GNU/Linux,
       семейство ОС \*BSD, Android, Solaris и т.д. (*прим.перев.*)
.. [4] **q**\ uietly -- *англ.* "тихо" (*прим.перев.*)
.. [5] **r**\ ecursive -- *англ.* "рекурсивно" (*прим.перев.*)
.. [6] raw -- *англ.* "сырой", "необработанный" (*прим.перев*)
.. [7] bug fixing -- устранение "багов", исправление ошибок (*прим.перев*)
.. [8] verbosity -- *англ.* "многословность". Применительно к компьютерным 
       программам обозначает степень подробности выводимых программой сообщений,
       т.е. степень "разговорчивости" программы. Отсюда и название этого 
       параметра (*прим.перев*)

